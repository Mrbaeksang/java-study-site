<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Collections API 완벽 가이드</title>
    <link rel="stylesheet" href="css/style.css">
    <style>
        .section {
            background: var(--vscode-darker);
            border: 1px solid var(--vscode-highlight);
            border-radius: 8px;
            margin: 2rem auto;
            padding: 2rem;
            max-width: 1000px;
        }

        .method-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            margin: 2rem 0;
        }

        .example-box {
            background: var(--vscode-bg);
            border-radius: 6px;
            padding: 1.5rem;
            margin: 1rem 0;
        }

        .code-block {
            background: #2d2d2d;
            padding: 1rem;
            border-radius: 6px;
            font-family: 'Consolas', monospace;
            overflow-x: auto;
            margin: 1rem 0;
            white-space: pre;
            line-height: 1.5;
        }

        .note {
            border-left: 4px solid var(--vscode-blue);
            padding: 1rem;
            margin: 1rem 0;
            background: rgba(0, 122, 204, 0.1);
        }

        .warning {
            border-left: 4px solid #f97583;
            padding: 1rem;
            margin: 1rem 0;
            background: rgba(249, 117, 131, 0.1);
        }

        .tip {
            border-left: 4px solid #85e89d;
            padding: 1rem;
            margin: 1rem 0;
            background: rgba(133, 232, 157, 0.1);
        }
    </style>
</head>
<body>
    <header>
        <h1>🔄 Collections API 완벽 가이드</h1>
        <nav>
            <a href="index.html" class="button">홈으로 돌아가기</a>
        </nav>
    </header>

    <main>
        <!-- 개요 섹션 -->
        <section class="section">
            <h2>📚 Collections API 개요</h2>
            <p>Collections 클래스는 컬렉션을 다루는 유용한 정적 메서드들을 제공합니다.</p>

            <div class="note">
                <h3>주요 기능</h3>
                <ul>
                    <li>정렬 (sort)</li>
                    <li>검색 (binarySearch)</li>
                    <li>섞기 (shuffle)</li>
                    <li>최대/최소값 찾기 (max/min)</li>
                    <li>컬렉션 변경 (reverse, swap)</li>
                    <li>동기화 (synchronizedList/Set/Map)</li>
                    <li>불변 컬렉션 생성 (unmodifiableList/Set/Map)</li>
                </ul>
            </div>
        </section>

        <!-- 정렬 메서드 -->
        <section class="section">
            <h2>🔄 정렬 메서드</h2>

            <div class="example-box">
                <h3>기본 정렬</h3>
                <div class="code-block">
// 리스트 정렬 (오름차순)
List<String> fruits = new ArrayList<>(Arrays.asList("banana", "apple", "orange"));
Collections.sort(fruits);
System.out.println(fruits);  // [apple, banana, orange]

// 역순 정렬
Collections.reverse(fruits);
System.out.println(fruits);  // [orange, banana, apple]

// 커스텀 Comparator를 사용한 정렬
List<Person> people = new ArrayList<>();
people.add(new Person("Kim", 25));
people.add(new Person("Lee", 30));
people.add(new Person("Park", 20));

// 나이순 정렬
Collections.sort(people, (p1, p2) -> p1.age - p2.age);

// 이름 길이순 정렬
Collections.sort(people, (p1, p2) -> p1.name.length() - p2.name.length());</div>
            </div>

            <div class="example-box">
                <h3>이진 검색</h3>
                <div class="code-block">
// 정렬된 리스트에서 요소 찾기
List<Integer> numbers = Arrays.asList(1, 3, 5, 7, 9);
int index = Collections.binarySearch(numbers, 5);
System.out.println("5의 위치: " + index);  // 2

// 커스텀 Comparator를 사용한 이진 검색
List<Person> people = new ArrayList<>();
people.add(new Person("Kim", 25));
people.add(new Person("Lee", 30));
people.add(new Person("Park", 20));

// 먼저 정렬
Collections.sort(people, (p1, p2) -> p1.age - p2.age);

// 나이로 검색
Person searchKey = new Person("", 25);
int personIndex = Collections.binarySearch(
    people,
    searchKey,
    (p1, p2) -> p1.age - p2.age
);</div>
            </div>
        </section>

        <!-- 유틸리티 메서드 -->
        <section class="section">
            <h2>🛠 유틸리티 메서드</h2>

            <div class="example-box">
                <h3>컬렉션 조작</h3>
                <div class="code-block">
// 최대/최소값 찾기
List<Integer> numbers = Arrays.asList(3, 1, 4, 1, 5, 9, 2, 6, 5);
int max = Collections.max(numbers);  // 9
int min = Collections.min(numbers);  // 1

// 특정 값으로 채우기
List<String> list = new ArrayList<>(Arrays.asList("a", "b", "c"));
Collections.fill(list, "X");  // [X, X, X]

// 빈도수 계산
int frequency = Collections.frequency(numbers, 5);  // 2

// 두 요소의 위치 교환
Collections.swap(list, 0, 2);  // 첫 번째와 마지막 요소 교환</div>
            </div>

            <div class="example-box">
                <h3>불변/동기화 컬렉션</h3>
                <div class="code-block">
// 불변 리스트 생성
List<String> mutableList = new ArrayList<>(Arrays.asList("a", "b", "c"));
List<String> immutableList = Collections.unmodifiableList(mutableList);

// 동기화된 리스트 생성
List<String> syncList = Collections.synchronizedList(new ArrayList<>());

// 싱글톤 컬렉션 생성
Set<Integer> singleton = Collections.singleton(42);
List<String> singletonList = Collections.singletonList("only one");
Map<String, Integer> singletonMap = Collections.singletonMap("key", 1);</div>
            </div>
        </section>

        <!-- 실무 활용 예제 -->
        <section class="section">
            <h2>💡 실무 활용 예제</h2>

            <div class="example-box">
                <h3>1. 안전한 컬렉션 공유</h3>
                <div class="code-block">
// 데이터 클래스
class DataService {
    private List<String> data = new ArrayList<>();
    
    public DataService() {
        data.add("중요한 데이터 1");
        data.add("중요한 데이터 2");
    }
    
    // 외부에 데이터를 공유할 때는 불변 리스트로 제공
    public List<String> getData() {
        return Collections.unmodifiableList(data);
    }
    
    // 내부에서만 데이터 수정 가능
    public void addData(String item) {
        data.add(item);
    }
}</div>
            </div>

            <div class="example-box">
                <h3>2. 멀티스레드 환경에서의 안전한 컬렉션 사용</h3>
                <div class="code-block">
class ThreadSafeService {
    private List<Task> tasks;
    
    public ThreadSafeService() {
        // ArrayList를 동기화된 리스트로 래핑
        tasks = Collections.synchronizedList(new ArrayList<>());
    }
    
    public void addTask(Task task) {
        tasks.add(task);
    }
    
    public void processTasks() {
        // 동기화된 리스트를 순회할 때는 synchronized 블록 사용
        synchronized (tasks) {
            for (Task task : tasks) {
                task.process();
            }
        }
    }
}</div>
            </div>

            <div class="example-box">
                <h3>3. 복잡한 정렬 조건 처리</h3>
                <div class="code-block">
// 여러 필드를 가진 클래스
class Product {
    String name;
    double price;
    int stock;
    
    // 생성자, getter, setter 생략
}

// 제품 목록 정렬
List<Product> products = new ArrayList<>();
// ... 제품 추가

// 가격 오름차순, 재고 내림차순으로 정렬
Collections.sort(products, (p1, p2) -> {
    int priceCompare = Double.compare(p1.price, p2.price);
    if (priceCompare != 0) {
        return priceCompare;
    }
    return Integer.compare(p2.stock, p1.stock);
});

// Comparator 체이닝을 사용한 방법
Collections.sort(products, 
    Comparator.comparingDouble((Product p) -> p.price)
              .thenComparingInt((Product p) -> -p.stock)
);</div>
            </div>
        </section>

        <!-- 성능 고려사항 -->
        <section class="section">
            <h2>⚡ 성능 고려사항</h2>
            
            <div class="warning">
                <h3>주의사항</h3>
                <ul>
                    <li>binarySearch는 반드시 정렬된 리스트에서만 사용</li>
                    <li>동기화된 컬렉션은 성능 오버헤드 발생</li>
                    <li>불변 컬렉션은 수정 시도 시 UnsupportedOperationException 발생</li>
                    <li>빈 컬렉션은 new 대신 Collections.empty___() 메서드 사용 권장</li>
                </ul>
            </div>
        </section>
    </main>
</body>
</html>
